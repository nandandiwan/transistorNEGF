"""Ozaki Continued-Fraction Representation (CFR) test & reference implementation.

This module implements a fast evaluation of Fermi-Dirac weighted Green's function
integrals using the continued fraction / pole expansion published by:

  T. Ozaki, Phys. Rev. B 75, 035123 (2007)

Goal
-----
Provide a self‑contained, well‑documented utility to:
  1. Generate poles & residues (continued fraction representation) for a chosen cutoff.
  2. Approximate the Fermi-Dirac distribution f((E-μ)/kT).
  3. Perform contour (pole) summation of integrals of the form:
		 I = -1/π * Im ∫ dE  G(E) f((E-μ)/kT)
	 without expensive real‑axis quadrature; instead using complex evaluations of G.
  4. Benchmark accuracy & performance vs brute force integration for test Green's functions.

We follow the implementation pattern visible in the existing project resources
(`continued_fraction_representation.py` & `cfr.py`), but keep everything here
for clarity when experimenting with new Green's functions.

Usage
------
Run as a script to see timing & error comparisons:
	python ozark_fermi_test.py

The main() routine will:
  * Build poles/residues for several cutoffs.
  * Evaluate Fermi-Dirac approximant vs exact.
  * Integrate a set of test Green's functions across a range of Fermi levels.
  * Print RMS / max errors and timing speedups.

Notes
------
* All energies are in eV.
* Temperature T in Kelvin; k_B = 8.617333262145e-5 eV/K.
* The expansion accuracy improves rapidly with cutoff; ~50–100 poles is often sufficient.
* For production NEGF density matrix traces, substitute your matrix Green's function trace
  (or function returning scalar trace) in place of the test functions below.

Author: (Auto‑generated by GitHub Copilot assistant)
"""

from __future__ import annotations

import numpy as np
import time
from dataclasses import dataclass
from typing import Callable, Sequence, Tuple
import os, sys

# Ensure project root added BEFORE importing project modules
_THIS_DIR = os.path.dirname(os.path.abspath(__file__))
_PROJECT_ROOT = os.path.abspath(os.path.join(_THIS_DIR, '..', '..'))  # path containing 'src'
if _PROJECT_ROOT not in sys.path:
	sys.path.insert(0, _PROJECT_ROOT)

from hamiltonian import Hamiltonian  # noqa: E402
from rgf import GreensFunction  # noqa: E402

KB_EV = 8.617333262145e-5  # Boltzmann constant in eV/K

# ----------------------------------------------------------------------------------
# Device Green's function (NEGF object) helper
# ----------------------------------------------------------------------------------
def create_greens_function(E):
	"""Return diagonal of retarded Green's function G^R(E) for a one_d_wire.

	Notes:
	  * Only real energies are used here (the current NEGF implementation may
		not support complex E for contour points yet).
	  * If the returned matrix is sparse, we extract its diagonal efficiently.
	Returns
	-------
	np.ndarray: diagonal elements G_ii^R(E)
	"""
	ham = Hamiltonian("one_d_wire")
	energy_grid = np.linspace(-3, 3, 301)
	gf_obj = GreensFunction(ham, energy_grid=energy_grid)
	G_R, *_ = gf_obj.compute_central_greens_function(E=E, ky=0)
	# Extract diagonal (handle dense / sparse)
	try:
		diag = G_R  # works for np.ndarray & scipy.sparse
	except AttributeError:
		diag = np.diag(np.asarray(G_R))
	return np.asarray(diag)

def negf_ldos_site(E_list: np.ndarray, site: int = 0) -> tuple[np.ndarray, np.ndarray]:
	"""Compute diagonal Green's function and LDOS for a single site over E_list.

	LDOS_i(E) = -1/pi * Im G_ii^R(E)
	Returns arrays (E_list, ldos_list)
	"""
	ldos = []
	for E in E_list:
		G_diag = create_greens_function(E)
		if site >= len(G_diag):
			raise IndexError("Site index out of range for Green's function diagonal")
		ldos.append(-1.0 / np.pi * np.imag(G_diag[site]))
	return E_list, np.array(ldos)

def negf_occupancy_real_axis(mu: float, T: float, E: np.ndarray, ldos: np.ndarray) -> float:
	f = fermi_dirac(E, mu, T)
	return float(np.trapz(ldos * f, E))

def negf_occupancy_cfr(mu: float, T: float, E: np.ndarray, ldos: np.ndarray, poles, residues) -> float:
	f_cfr = fermi_dirac_cfr(E, mu, T, poles, residues)
	return float(np.trapz(ldos * f_cfr, E))

def negf_cfr_test(mu: float = 0.0, T: float = 300.0, site: int = 0, cutoff: int = 40,
				  E_min: float = -1.5, E_max: float = 1.5, nE: int = 401) -> dict:
	"""Compute site occupancy via real-axis integration using exact vs CFR Fermi.

	This uses the user-requested create_greens_function(E) interface for each energy.
	(Not performance-optimized; repeated Hamiltonian construction per energy can be
	 optimized later by reusing a single GreensFunction instance.)
	Returns a dict with results and errors.
	"""
	E = np.linspace(E_min, E_max, nE)
	ldos_vals = []
	for val in E:
		diag = create_greens_function(val)
		if site >= len(diag):
			raise IndexError(f"Site {site} out of range (diag length {len(diag)})")
		ldos_vals.append(-1/np.pi * np.imag(diag[site]))
	ldos_vals = np.array(ldos_vals)
	occ_exact = negf_occupancy_real_axis(mu, T, E, ldos_vals)
	poles, residues = ozaki_poles_residues(cutoff)
	occ_cfr = negf_occupancy_cfr(mu, T, E, ldos_vals, poles, residues)
	err = occ_cfr - occ_exact
	return {
		'mu': mu,
		'T': T,
		'site': site,
		'cutoff': cutoff,
		'occupancy_exact': occ_exact,
		'occupancy_cfr': occ_cfr,
		'abs_error': abs(err),
		'rel_error': abs(err)/abs(occ_exact) if occ_exact != 0 else np.nan
	}


def negf_site_occupancy_ozaki(mu: float, T: float, site: int = 0, cutoff: int = 60,
							   E_min: float = -2.0, E_max: float = 2.0, nE: int = 501,
							   attempt_pole_sum: bool = False, R: float = 1e4) -> dict:
	"""Compute NEGF site occupancy leveraging Ozaki CFR.

	Two strategies:
	  1. (Always) Real-axis LDOS * CFR Fermi approximation (fast replacement for dense Fermi).
	  2. (Optional) Direct Ozaki pole-summation using complex Green's function evaluations
		 (attempted only if `attempt_pole_sum=True`). This may fail if the underlying
		 `GreensFunction.compute_central_greens_function` does not accept complex energies.

	Parameters
	----------
	mu, T : float
		Chemical potential (eV) and temperature (K).
	site : int
		Site index for diagonal LDOS.
	cutoff : int
		Number of CFR poles.
	E_min, E_max, nE : float, float, int
		Real energy window & resolution for LDOS sampling (used in method 1).
	attempt_pole_sum : bool
		If True, try complex-energy pole summation (method 2).
	R : float
		Large radius parameter for zero-moment term in pole summation.

	Returns
	-------
	dict with keys:
		occupancy_exact        (real-axis with exact Fermi)
		occupancy_cfr          (real-axis with CFR Fermi)
		occupancy_pole_sum     (if attempted & successful)
		errors and metadata.
	"""
	# Real-axis LDOS acquisition
	E = np.linspace(E_min, E_max, nE)
	_, ldos = negf_ldos_site(E, site=site)
	occ_exact = negf_occupancy_real_axis(mu, T, E, ldos)
	poles, residues = ozaki_poles_residues(cutoff)
	occ_cfr = negf_occupancy_cfr(mu, T, E, ldos, poles, residues)
	result = {
		'method': 'ldos_real_axis_cfr',
		'mu': mu,
		'T': T,
		'site': site,
		'cutoff': cutoff,
		'occupancy_exact': occ_exact,
		'occupancy_cfr': occ_cfr,
		'abs_error_cfr': abs(occ_cfr - occ_exact),
		'rel_error_cfr': abs(occ_cfr - occ_exact)/abs(occ_exact) if occ_exact else np.nan,
		'E_min': E_min,
		'E_max': E_max,
		'nE': nE,
	}

	if attempt_pole_sum:
		beta = 1.0 / (KB_EV * T)
		complex_pts = mu + 1j / (poles * beta)
		diag_vals = []
		pole_sum_supported = True
		for z in complex_pts:
			try:
				# Try complex energy; if fails, abort pole-sum path.
				diag = create_greens_function(z)
			except Exception as exc:  # noqa: BLE001
				pole_sum_supported = False
				result['pole_sum_error'] = f"Complex energy evaluation failed at {z}: {exc}"  # type: ignore
				break
			if site >= len(diag):
				pole_sum_supported = False
				result['pole_sum_error'] = f"Site {site} out of range for pole-sum diag length {len(diag)}"  # type: ignore
				break
			diag_vals.append(diag[site])
		if pole_sum_supported:
			# Build zero-moment term using a single large imaginary evaluation
			try:
				zero_diag = create_greens_function(1j * R)
				if site >= len(zero_diag):
					raise IndexError(f"Site {site} out of range for zero-moment diag length {len(zero_diag)}")
				zero_moment = 1j * R * zero_diag[site]
				# Σ 4 i / β * G(z_j) r_j  (site-diagonal contributions)
				diag_vals = np.asarray(diag_vals)
				term = 4j / beta * diag_vals * residues
				ans = zero_moment + np.imag(np.sum(term))
				occ_pole = float(np.real(ans) * (-1/np.pi))  # Include spectral prefactor guess
				result['occupancy_pole_sum'] = occ_pole
				result['abs_error_pole_sum'] = abs(occ_pole - occ_exact)
				result['rel_error_pole_sum'] = abs(occ_pole - occ_exact)/abs(occ_exact) if occ_exact else np.nan
			except Exception as exc:  # noqa: BLE001
				result['pole_sum_error'] = f"Zero-moment evaluation failed: {exc}"  # type: ignore

	return result
    
    
# --------------------------------------------------------------------------------------
# Pole & Residue Generation (Ozaki CFR)
# --------------------------------------------------------------------------------------

def ozaki_poles_residues(cutoff: int) -> Tuple[np.ndarray, np.ndarray]:
	"""Return (poles, residues) arrays for the continued fraction representation.

	Based on tridiagonal Jacobi matrix whose off-diagonal elements are:
		b_j = 1 / ( 2 * sqrt( (2j+1)(2j+3) ) ),  j = 0..cutoff-2

	Eigenvalues (positive) -> poles (a_j); residues via formula using first
	component of eigenvectors (see Ozaki PRB 75, 035123 Eq. 16 / related).

	We match the logic in existing resource code but avoid SciPy dependency:
	a dense symmetric tridiagonal eigenproblem solved with numpy.linalg.eigh.
	For moderate cutoff (<= 800) this is fine for experimentation.

	Parameters
	----------
	cutoff : int
		Number of continued fraction levels (roughly number of poles before filtering).

	Returns
	-------
	poles : np.ndarray (M,)
		Positive eigenvalues (a_j) > 0.
	residues : np.ndarray (M,)
		Corresponding residues (b_j) for Fermi-Dirac approximant.
	"""
	if cutoff < 2:
		raise ValueError("cutoff must be >= 2")

	j = np.arange(cutoff - 1)
	b = 1.0 / (2.0 * np.sqrt((2 * (j + 1) - 1) * (2 * (j + 1) + 1)))
	# Build symmetric tridiagonal matrix J of size cutoff x cutoff
	# Diagonals are zero; off-diagonals are b.
	J = np.zeros((cutoff, cutoff), dtype=float)
	idx = np.arange(cutoff - 1)
	J[idx, idx + 1] = b
	J[idx + 1, idx] = b
	# Solve eigenproblem
	vals, vecs = np.linalg.eigh(J)
	# Residues formula: 0.25 * |v_0j|^2 / vals_j^2
	# Keep only positive poles
	mask = vals > 0
	poles = vals[mask]
	v0 = vecs[0, mask]
	residues = 0.25 * (np.abs(v0) ** 2) / (poles ** 2)
	return poles, residues


def fermi_dirac(E: np.ndarray | float, mu: float, T: float) -> np.ndarray:
	"""Exact Fermi-Dirac distribution f(E, mu, T)."""
	beta = 1.0 / (KB_EV * T)
	x = (E - mu) * beta
	# Stable evaluation
	out = np.empty_like(np.asarray(x), dtype=float)
	x_arr = np.asarray(x)
	# Use clipping for stability
	large_pos = x_arr > 50
	large_neg = x_arr < -50
	mid = ~(large_pos | large_neg)
	out[large_pos] = 0.0
	out[large_neg] = 1.0
	out[mid] = 1.0 / (np.exp(x_arr[mid]) + 1.0)
	return out


def fermi_dirac_cfr(E: np.ndarray | float, mu: float, T: float,
					 poles: np.ndarray, residues: np.ndarray) -> np.ndarray:
	"""Approximate Fermi function using Ozaki continued fraction expansion.

	f((E-mu)/(kT)) ≈ 0.5 - Σ_j r_j [ 1/(x - i/a_j) + 1/(x + i/a_j) ],
		where x = (E - mu)/(kT), a_j = poles_j, r_j = residues_j.

	Parameters
	----------
	E : array-like
		Energies (eV)
	mu : float
		Chemical potential (eV)
	T : float
		Temperature (K)
	poles, residues : arrays
		Expansion parameters from ozaki_poles_residues.
	"""
	kT = KB_EV * T
	x = (np.asarray(E, dtype=float) - mu) / kT
	x_complex = x[..., None]  # shape (..., 1)
	aj = poles[None, ...]
	rj = residues[None, ...]
	# Vectorized sum
	denom_pos = x_complex - 1j / aj
	denom_neg = x_complex + 1j / aj
	s = (rj / denom_pos) + (rj / denom_neg)
	approx = 0.5 - np.sum(s, axis=-1)
	return approx.real  # Imag parts cancel ideally; numerical noise small.


# --------------------------------------------------------------------------------------
# Ozaki Contour Integral (Pole Summation)
# --------------------------------------------------------------------------------------

def ozaki_integral(
	gf: Callable[[complex | np.ndarray], complex | np.ndarray],
	mu: float,
	T: float,
	poles: np.ndarray,
	residues: np.ndarray,
	R: float = 1.0e4,
) -> float:
	"""Compute I = -1/pi * Im ∫_{-∞}^{∞} dE G(E) f((E-μ)/kT) using pole summation.

	Following logic in provided CFR reference: choose a *very* large R and evaluate
	zero_moment = i R G(iR). Then:
		I = Re( zero_moment + Im( Σ_j 4 i / β * G( μ + i/(a_j β) ) * r_j ) )

	(Here r_j = residues_j, a_j = poles_j, β = 1/(k_B T)).

	Parameters
	----------
	gf : callable
		Green's function G(z) analytic in upper half-plane; returns complex values.
	mu : float
		Chemical potential (eV).
	T : float
		Temperature (K).
	poles, residues : arrays
		Ozaki expansion parameters.
	R : float
		Large radius for zero-moment term; should be >> characteristic energy scales.

	Returns
	-------
	integral : float
		Approximate value of integral.
	"""
	beta = 1.0 / (KB_EV * T)
	z_inf = 1j * R
	zero_moment = 1j * R * gf(z_inf)
	# Points where to evaluate G: z_j = mu + i/(a_j beta)
	z_j = mu + 1j / (poles * beta)
	G_vals = np.asarray(gf(z_j))
	term = 4j / beta * G_vals * residues
	ans = zero_moment + np.imag(np.sum(term))
	return float(np.real(ans))


def brute_force_integral(
	gf: Callable[[np.ndarray], np.ndarray],
	mu: float,
	T: float,
	E_window: float = 50.0,
	n_points: int = 1_000_000,
	eta: float = 5e-4,
	adaptive_refine: bool = True,
) -> float:
	"""Reference real-axis integration with simple (optionally refined) trapezoidal rule.

	I = -1/pi * Im ∫ dE G(E + i eta) f((E-μ)/kT)

	With very narrow Lorentzian peaks (η ≪ ΔE grid) naive sampling underestimates area.
	We optionally add local refinement windows around detected peaks (where |Im G| large).
	This remains a *slow* reference and is not intended for production.
	"""
	E = np.linspace(mu - E_window, mu + E_window, n_points)
	z = E + 1j * eta
	G = gf(z)
	f = fermi_dirac(E, mu, T)
	integrand = -1.0 / np.pi * np.imag(G) * f
	val = float(np.trapz(integrand, E))
	if not adaptive_refine:
		return val
	# Simple refinement: locate top K peaks in |Im G| and refine locally
	K = 6
	idx = np.argsort(np.abs(np.imag(G)))[-K:]
	E_ref_total = []
	integrand_ref_total = []
	for center_idx in idx:
		Ec = E[center_idx]
		window = 50 * eta  # narrow high-res window
		Er = np.linspace(Ec - window, Ec + window, 4000)
		zr = Er + 1j * eta
		Gr = gf(zr)
		fr = fermi_dirac(Er, mu, T)
		integrand_r = -1.0 / np.pi * np.imag(Gr) * fr
		E_ref_total.append(Er)
		integrand_ref_total.append(integrand_r)
	if E_ref_total:
		# Replace coarse contribution within refined windows: subtract coarse part, add refined
		for Er, integrand_r in zip(E_ref_total, integrand_ref_total):
			mask = (E >= Er.min()) & (E <= Er.max())
			coarse_sub = float(np.trapz(integrand[mask], E[mask]))
			fine_add = float(np.trapz(integrand_r, Er))
			val += fine_add - coarse_sub
	return val


# --------------------------------------------------------------------------------------
# Test Green's Functions (scalar examples)
# --------------------------------------------------------------------------------------

def test_gf_rational(z: complex | np.ndarray) -> complex | np.ndarray:
	"""Simple sum of poles typical for LDOS-like structures.
	G(z) = Σ_j 1/(z - E_j) with chosen E_j.
	"""
	E_levels = np.array([-7.0, -2.5, -1.0, 0.5, 3.0, 5.0])
	out = np.zeros_like(np.asarray(z), dtype=complex)
	for E0 in E_levels:
		out += 1.0 / (np.asarray(z) - E0)
	return out


def test_gf_frac(z: complex | np.ndarray) -> complex | np.ndarray:
	"""Alternate test using t_order_frac-like building blocks: 1/(z - E) not squared.
	Equivalent to test_gf; kept to mirror resource examples if expanded later.
	"""
	return test_gf_rational(z)


# --------------------------------------------------------------------------------------
# Benchmark / Validation Harness
# --------------------------------------------------------------------------------------

@dataclass
class BenchmarkResult:
	cutoff: int
	rms_error: float
	max_error: float
	mean_abs_error: float
	speedup_vs_bruteforce: float
	brute_force_time: float
	ozaki_time: float


def benchmark(
	gf: Callable[[complex | np.ndarray], complex | np.ndarray],
	mu_values: Sequence[float],
	T: float,
	cutoffs: Sequence[int],
	brute_force_kwargs: dict | None = None,
) -> list[BenchmarkResult]:
	"""Run benchmarks for a set of cutoffs; compare Ozaki vs brute force integrals.

	For fairness, we compute brute force ONCE per μ (costly) and reuse results.
	"""
	if brute_force_kwargs is None:
		brute_force_kwargs = dict(E_window=50.0, n_points=200_000, eta=1e-4)

	# Precompute brute force integrals
	bf_results = []
	t0 = time.perf_counter()
	for mu in mu_values:
		bf_results.append(brute_force_integral(gf, mu, T, **brute_force_kwargs))
	brute_force_time_total = time.perf_counter() - t0

	results: list[BenchmarkResult] = []
	for cutoff in cutoffs:
		poles, residues = ozaki_poles_residues(cutoff)
		oz_vals = []
		t1 = time.perf_counter()
		for mu in mu_values:
			oz_vals.append(ozaki_integral(gf, mu, T, poles, residues))
		oz_time = time.perf_counter() - t1
		oz_vals = np.array(oz_vals)
		bf_arr = np.array(bf_results)
		err = oz_vals - bf_arr
		rms = float(np.sqrt(np.mean(err**2)))
		max_err = float(np.max(np.abs(err)))
		mae = float(np.mean(np.abs(err)))
		speedup = (brute_force_time_total / oz_time) if oz_time > 0 else np.inf
		results.append(
			BenchmarkResult(
				cutoff=cutoff,
				rms_error=rms,
				max_error=max_err,
				mean_abs_error=mae,
				speedup_vs_bruteforce=speedup,
				brute_force_time=brute_force_time_total,
				ozaki_time=oz_time,
			)
		)
	return results


def demo_fermi_accuracy(mu: float, T: float, cutoff: int) -> Tuple[float, float]:
	"""Return (rms_error, max_error) for Fermi approximant on a grid."""
	poles, residues = ozaki_poles_residues(cutoff)
	E = np.linspace(mu - 2.0, mu + 2.0, 5000)
	exact = fermi_dirac(E, mu, T)
	approx = fermi_dirac_cfr(E, mu, T, poles, residues)
	diff = approx - exact
	rms = float(np.sqrt(np.mean(diff**2)))
	mx = float(np.max(np.abs(diff)))
	return rms, mx


# --------------------------------------------------------------------------------------
# Discrete-level analytic occupancy demonstration
# --------------------------------------------------------------------------------------

E_LEVELS = np.array([-7.0, -2.5, -1.0, 0.5, 3.0, 5.0])

def analytic_occupancy(mu: float, T: float) -> float:
	"""Exact Σ f(E_j) for the discrete pole Green's function."""
	return float(np.sum(fermi_dirac(E_LEVELS, mu, T)))

def cfr_occupancy(mu: float, T: float, poles: np.ndarray, residues: np.ndarray) -> float:
	"""Approximate Σ f(E_j) using CFR approximant evaluated only at discrete levels."""
	f_approx = fermi_dirac_cfr(E_LEVELS, mu, T, poles, residues)
	return float(np.sum(f_approx))


def main():  # pragma: no cover - interactive / performance demo
	T = 300.0
	mu_values = np.linspace(-1.0, 1.0, 25)
	cutoffs = [10, 20, 40, 60, 80, 100]
	print("Benchmarking Ozaki CFR integral vs brute force for test_gf_rational ...")
	results = benchmark(test_gf_rational, mu_values, T, cutoffs,
						brute_force_kwargs=dict(E_window=40.0, n_points=120_000, eta=5e-5))
	print("cutoff |  RMS err   |  Max err   |  MAE       | speedup  | oz_time (s) | brute_force_time (s)")
	for r in results:
		print(f"{r.cutoff:6d} | {r.rms_error:9.3e} | {r.max_error:9.3e} | {r.mean_abs_error:9.3e} |"
			  f" {r.speedup_vs_bruteforce:7.2f} | {r.ozaki_time:11.3f} | {r.brute_force_time:18.3f}")

	print("\nFermi function approximation errors (grid ±2 eV around μ=0):")
	for c in cutoffs:
		rms, mx = demo_fermi_accuracy(0.0, T, c)
		print(f"cutoff={c:4d}: rms={rms:.3e}, max={mx:.3e}")

	# Quick single integral showcase
	mu0 = 0.25
	poles, residues = ozaki_poles_residues(60)
	oz_val = ozaki_integral(test_gf_rational, mu0, T, poles, residues)
	bf_val = brute_force_integral(test_gf_rational, mu0, T, E_window=40.0, n_points=200_000, eta=1e-4)
	print(f"\nExample contour-like integral μ={mu0:.2f} eV: OzakiExpr={oz_val:.6e}, BruteForce={bf_val:.6e}, diff={oz_val-bf_val:.3e}")
	print("(Note: Current ozaki_integral implements raw CFR expression; mapping to physical -1/pi Im ∫ G f may need scaling depending on definition of G.)")

	# Discrete occupancy accuracy test (physically relevant for this toy GF)
	print("\nDiscrete occupancy Σ f(E_j) using CFR approximant vs exact:")
	for c in [10, 20, 40, 60, 80, 100]:
		p, r_ = ozaki_poles_residues(c)
		occ_exact = analytic_occupancy(mu0, T)
		occ_cfr = cfr_occupancy(mu0, T, p, r_)
		print(f"cutoff={c:3d}: occ_exact={occ_exact:.6f}, occ_cfr={occ_cfr:.6f}, err={occ_cfr-occ_exact:.2e}")

	try:
		import matplotlib.pyplot as plt  # optional
		E = np.linspace(-1.0, 1.0, 2000)
		poles_plot, residues_plot = ozaki_poles_residues(80)
		f_exact = fermi_dirac(E, 0.0, T)
		f_approx = fermi_dirac_cfr(E, 0.0, T, poles_plot, residues_plot)
		plt.figure(figsize=(6,4))
		plt.plot(E, f_exact, label='Exact Fermi', lw=2)
		plt.plot(E, f_approx, '--', label='CFR approx (cutoff=80)')
		plt.xlabel('E (eV)')
		plt.ylabel('f(E)')
		plt.legend()
		plt.tight_layout()
		plt.show()
	except Exception as exc:  # pragma: no cover
		print("Matplotlib plot skipped (", exc, ")")


if __name__ == "__main__":  # pragma: no cover
	main()

